%{
/* need this for the call to atoi(), atof() below */
#include <math.h>
#include <string.h>
#include "ObjectTree.h"
#include "ritchie.tab.h" /* Generated by bison. */
#include "ritc.h"

#define INDENT_STACK_MAX 512

int g_current_line_indent = 0;
int g_indent_levels[INDENT_STACK_MAX];
int g_indent_levels_index = -1;
int g_is_fake_outdent_symbol = 0;

int  stack_top() { return  g_indent_levels[g_indent_levels_index]; }
int  stack_pop() { return  g_indent_levels[g_indent_levels_index--]; }
void stack_push(int val) { g_indent_levels[++g_indent_levels_index] = val; }

#define YY_USER_INIT { \
    stack_push(0); \
    BEGIN(initial); \
}

//#define YY_DECL extern int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, yyscan_t scanner )


int yycolumn = 1;
void set_yycolumn(int val) {
    yycolumn = val;
    //yylloc.first_column = yycolumn;
    //yylloc.last_column = yycolumn + yyleng - 1;
}

/*
#define YY_USER_ACTION { \
    yylloc.first_line = yylloc.last_line = yylineno; \
    set_yycolumn(yycolumn); \
    yycolumn += yyleng; \
}
*/

#define YY_USER_ACTION { \
    set_yycolumn(yycolumn); \
}


%}

%option yylineno
%option noyywrap

%x initial
%x indent
%s normal

%option bison-bridge bison-locations

alphabetic    [a-zA-Z]
numeral       [0-9]
alphanumeric  {alphabetic}|{numeral}
integer       {numeral}+
float         {numeral}+"."{numeral}*
identifier    {alphabetic}{alphanumeric}*

mathOp        "+"|"-"|"*"|"/"|"^^"
assignment    "="

mathAssign    "+="|"-="|"*="|"/="
bitwiseOp      "||"|"&&"

objectLink    "::"
conditionLink "?"

%%
        int indent_caller = normal;

<initial>.  { set_yycolumn(yycolumn-1); indent_caller = normal; yyless(0); BEGIN(indent); }
<initial>\n { indent_caller = normal; yyless(0); BEGIN(indent); return ENDOFLINE; }    

<indent>" "     { g_current_line_indent++; }
<indent>\t      { g_current_line_indent++; }
<indent>\n      { g_current_line_indent = 0; /* ignoring blank line */ }
<indent><<EOF>> { 
                    // When encountering the end of file, we want to emit an
                    // outdent for all indents currently left.
                    if(stack_top() != 0) {
                        stack_pop();

                        // See the same code below (<indent>.) for a rationale.
                        if(g_current_line_indent != stack_top()) {
                            size_t i;
                            unput('\n');
                            for(i = 0 ; i < stack_top() ; ++i) {
                                unput(' ');
                            }
                        } else {
                            BEGIN(indent_caller);
                        }

                        printf("lexer: EOF OUTDENT\n");
                        return UNINDENT;
                    } else {
                        yyterminate();
                    }
                }

<indent>.       { 
                    if(!g_is_fake_outdent_symbol) {
                        unput(*yytext);
                    }
                    g_is_fake_outdent_symbol = 0;
                    // -2: -1 for putting it back and -1 for ending at the last space.
                    set_yycolumn(yycolumn-1);

                    // Indentation level has increased. It can only ever
                    // increase by one level at a time. Remember how many
                    // spaces this level has and emit an indentation token.
                    if(g_current_line_indent > stack_top()) {
                        printf("lexer: INDENT\n"); 
                        stack_push(g_current_line_indent);
                        BEGIN(indent_caller);
                        return INDENT;
                    } else if(g_current_line_indent < stack_top()) {
                        printf("lexer: OUTDENT\n"); 
                        // Outdenting is the most difficult, as we might need to
                        // outdent multiple times at once, but flex doesn't allow
                        // emitting multiple tokens at once! So we fake this by
                        // 'unput'ting fake lines which will give us the next
                        // outdent.
                        stack_pop();

                        if(g_current_line_indent != stack_top()) {
                            size_t i;
                            // Unput the rest of the current line, including the newline.
                            // We want to keep it untouched.
                            for(i = 0 ; i < g_current_line_indent ; ++i) {
                                unput(' ');
                            }
                            unput('\n');
                            // Now, insert a fake character indented just so
                            // that we get a correct outdent the next time.
                            unput('.');
                            // Though we need to remember that it's a fake one
                            // so we can ignore the symbol.
                            g_is_fake_outdent_symbol = 1;
                            for(i = 0 ; i < stack_top() ; ++i) {
                                unput(' ');
                            }
                            unput('\n');
                        } else {
                            BEGIN(indent_caller);
                        }
                        return UNINDENT;
                    } else {
                        // No change in indentation, not much to do here...
                        BEGIN(indent_caller);
                    }
                }

<normal>\n    { printf("EOL\n"); 
                g_current_line_indent = 0; 
                indent_caller = YY_START; 
                BEGIN(indent);
                return ENDOFLINE; }


<normal>{integer}     { printf("lexer: int\n");    yylval->ival = atoi(yytext);   return INT; }
<normal>{float}       { printf("lexer: float\n");  yylval->fval = atof(yytext);   return FLOAT; }
<normal>{mathOp}      { printf("lexer: mathOp\n"); yylval->sval = strdup(yytext); return MATH_OP; }
<normal>{identifier}  { printf("lexer: ident\n");  yylval->sval = strdup(yytext);
                        Object* exists = findByName(yytext);
                        if (!exists || exists->type == Variable)
                          return IDENT;
                        else if (exists->type == Function)
                          return VERB;
                        else if (exists->type == Type)
                          return TYPE;
                        else
                          return IDENT;
                      }


<normal>{assignment}   { printf("lexer: assignment\n"); yylval->sval = strdup(yytext); return ASSIGNMENT; }
<normal>{conditionLink} { printf("lexer: CondLink\n" ); yylval->sval = strdup(yytext); return CONDITIONLINK; }

<normal>{bitwiseOp}    { printf("lexer: bitwiseOp\n" ); yylval->sval = strdup(yytext); return BITWISEOP;  }
<normal>{mathAssign}   { printf("lexer: MathAssign\n"); yylval->sval = strdup(yytext); return MATHASSIGN; }

<normal><<EOF>>       { return ENDOFFILE; }
<normal>[ \t]+        /* eat up whitespace */
<normal>"("           { printf("lexer: (\n"); return LPAREN; }
<normal>")"           { printf("lexer: )\n"); return RPAREN; }
<normal>.             { printf("Unknown symbol encountered: '%s'\n", yytext); }

%%


